# -*- mode: python -*-
# Building ocaml based applications is somewhat challenging:
#
# a) things must be built in dependency order
#    (meaning that all dependencies of a module must be built before
#    the module itself)
#
# b) list of unique modules constituting final linking stage must be
#    supplied to the ocaml linker also in dependency order
#
# Following is an approximation[1] of what llpp's[2] build
# automation[3] does.
#
# [1] Linking step is omitted
# [2] https://repo.or.cz/llpp.git
# [3] https://repo.or.cz/llpp.git/blob/HEAD:/build.bash
#
# Things do work, but serially, even though there are steps
# that can be done in parallel.
#
# build.bash is modelled after previous[4] (Shake[5] based)
# approach used in llpp
#
# [4] https://repo.or.cz/llpp.git/blob/cafe803fe4017d9659bb5a8c9d6ec078fa497ab2:/Shakefile.hs
# [5] https://shakebuild.com/
#
# Worth noting that Shakefile.hs (and build.bash) track command
# lines used to build artifacts, an idea taken from Ninja [6]
#
# [6] https://ninja-build.org/
#
# Command line tracking is a core feature of Ninja but had to be
# manually taken care of in Shakefile.hs. (Worth noting that Linux
# kernel's GNU Makefile based build system also tracks command lines)
#
# While build.bash lacks parallel features of Shakefile.hs it has
# some advantages. No claim is made that those advantages are
# impossible in Shake, just that it wasn't done.
#
# What is claimed:
#  a) transitive dependency chain of Shake is big (GHC, Cabal, etc)
#  b) I cannot handle it
#  c) given arbitrary linux/macos system it's _much_ easier[7] to
#     build llpp with build.bash
#
# [7] Judging by the effort it took to build llpp with build.bash on:
#      1) 2008 PPC(G4) mac mini (llpp's place of birth)
#      2) rapspberry pi
#      3) M1 mac book air
#  (cf. https://repo.or.cz/llpp.git/blob/HEAD:/BUILDING)
#
# Requirements for build automation:
#  discover ocaml dependencies automatically (+)
#  rebuild only what is necessary tracking most inputs (+)
#                          (tool versions, command lines, etc)
#  exploit parallelism (-)

def build (target):
    if not is_fresh (target):
        dobuild (target)
        remember (target)

def dobuild (target):
    deps = compute_deps (target)
    for dep in deps:
        build (dep)
    execute (target.commands) or die

def digest (path):
    return checksum_as_string (path) # any mapping: path -> string

def key (target):
    deps = compute_deps (target)
    paths = target.output_filenames ++ deps
    s = ""
    for path in paths:
        s += digest (path)
    return s

def is_fresh (target):
    key_now = key (target)
    past_file = open (target.name + ".past")
    key_was = read (past_file)
    close (past_file)
    return key_now == key_was

def remember (target):
    past_file = open (target.name + ".past")
    write (past_file, key (target))
    close (past_file)

def compute_deps (target):
    # https://caml.inria.fr/pub/docs/manual-ocaml/depend.html
    p = execute_and_pipe ("ocamlc -depend " + target.name) or die
    s = ""
    while read (p) as d:
        s += d
    close (p)
    return s
