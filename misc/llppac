#!/bin/sh
set -e

die() {
    echo "$1" >&2
    exit 1
}

cachedir="${XDG_CACHE_HOME:-$HOME/.cache}/llpp"
test -d "$cachedir" || die "cache directory '$cachedir' does not exist"

caspsuf=
type=

executable_p() {
    command -v "$1" >/dev/null 2>&1
}

missing() {
    executable_p $1 || \
        eval "$1() { die \"$2 is needed for \$type conversion\"; }"
}

text() {
    cat <<EOF
<pre style="font-size: ${1}pt;">
=== $1 ===
Lorem ipsum dolor sit amet, consectetur...datat non proident, sunt in
culpa qui officia deserunt mollit anim id est laborum.
Posting Soccer Goals On Vine Is Illegal, Say England's Premier League
abcdefghizklmnopqrstwxyz
ABCDEFGHIZKLMNOPQRSTWXYZ
абвгдеёжзийклмнопрстуфхцчшщэюя
АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЭЮЯ
\`1234567890-=\\
~!@#\$$%^&*()_+|
[];',./
{}:"&lt;&gt;?"
S in S9 59 is like 5
3ЗЭэзээз3ЗqgO0o ijklI1| bgqpykvwlliliiijil1
Ре́ҙю̈мȩ̊́́́
01234567890 3ДС ЗДС
- - (~-) ~ ~ (-~)
curly vs plain braces {} () {}

echo \${@:5}
life           [l i fe]
weird          [we i rd]
Before         [Bef ore, Be for e]
higher         [gh]
multi          [mu lti]
languge        [an]
when           [wh]
kerning        [rn]
мне            [мн е]
oiled          [oi led]
mkfifo         [mk f i fo, mk f i fo]
didn't         [di dn't]
</pre>
EOF
}

maketext() {
    # https://github.com/react-boilerplate/react-boilerplate/issues/1340
    test -d "$cachedir/fonts" || mkdir "$cachedir/fonts"
    cat >"$cachedir/fonts/text.html" <<EOF
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <style type="text/css">
      @font-face {
          font-family: 'moo';
          src: url('$1');
      }
      pre {
          font-family: "moo";
      }
    </style>
    <title>test</title>
  </head>

  <body>
EOF
    for size in 6 8 10 12 4 2; do
        text $size >>"$cachedir/fonts/text.html"
    done;
    cat >>"$cachedir/fonts/text.html" <<EOF
  </body>
</html>
EOF
}

trap 'test -n "$casp" && rm -f "$casp"' 0

while getopts c:m:t:f opt; do
    case $opt in
        m) mime=$OPTARG;;
        t) type=$OPTARG;;
        f) force=true;;
        c) css="-s $OPTARG";;
        ?) die "usage: $0 [-c css] [-m mime/type] [-t filter] [-f] [path|url]";;
    esac
done
shift $(($OPTIND - 1))
test -z "$1" && die "usage $0: path"

origin="$1"
if ${force-test ! -e "$1"} && expr >/dev/null "$1" : "\(ftp\|https\?\)://"; then
    if executable_p wget; then
        dl() {
            wget -q $1 -O $2
        }
    elif executable_p curl; then
        dl() {
            curl $1 -o $2
        }
    else
        die "no program to fetch remote urls found"
    fi

    md5of="$cachedir/$(basename "$1")"
    dl "$1" "$md5of" || test -e "$md5of"
    shift
    set -- "$md5of" "$@"
else
    md5of="$1"
fi

test -z "$type" && {
    ft=$(file -L --mime-type -b "$1") || die "$ft"
}

case $ft in
    application/x-gzip | application/x-compress) dc=zcat;;
    application/x-xz) dc=xzcat;;
    application/x-bzip2) dc=bzcat;;
    *) unset dc || true;;
esac

filt='"${dc-cat}" "$1" |'

if test -z "$type"; then
    test -z "$mime" && mime=$(file -L --mime-type -bz "$1" || die "$mime")
    case $mime in
        application/postscript) type=ps;;
        application/pdf) type=pdf;;
        image/vnd.djvu) type=djvu;;
        text/html) type=html;;
        text/plain) type=text;;
        application/msword) type=word;;
        application/vnd.openxmlformats-officedocument.*  \
            | application/vnd.ms-powerpoint              \
            | application/vnd.ms-excel                   \
            | application/vnd.oasis.opendocument.*) type=uno;;
        image/svg+xml) type=svg;;
        image/png | image/jpeg) test -n "$dc" && type="image" || type="image2";;
        image/*) type=image;;
        application/x-dvi) type=dvi;;
        application/x-font-ttf                  \
            | application/vnd.ms-opentype       \
            | application/font-sfnt) type=font;;
        *) die "unhandled file type: '$mime'";;
    esac
fi

caspsuf=".pdf"
case $type in
    ps) conv='ps2pdf - "$casp"';;
    image2|pdf) test -z "$dc" && exec llpp "$@" || conv='cat >"$casp"';;
    texi) {
        missing texi2html "texi2html(http://www.nongnu.org/texi2html/)"
        missing prince "PrinceXML(http://www.princexml.com/)"
        conv='texi2html - -o - | prince $css - -o "$casp"'
    };;
    djvu) {
        missing ddjvu "ddjvu(http://djvu.sourceforge.net/doc/man/ddjvu.html)"
        conv='ddjvu -format=pdf - "$casp"'
    };;
    html) {
        missing prince "PrinceXML(http://www.princexml.com/)"
        conv='prince $css - -o "$casp"'
    };;
    html2epub) {
        missing pandoc "pandoc(http://pandoc.org)"
        caspsuf=".epub"
        conv='pandoc -r html - -w epub -o "$casp"'
    };;
    word) {
        if executable_p unoconv && test -z "$dc"; then
            unset filt
            conv='unoconv -o "$casp" "$1"'
        else
            missing antiword "antiword or unoconv"
            conv='antiword -m 8859-1.txt -a a4 - >"$casp"'
        fi
    };;
    uno) {
        test -n "$dc" && die "cannot convert compressed '$mime'"
        unset filt
        missing unoconv "unoconv(http://dag.wiee.rs/home-made/unoconv/)"
        conv='unoconv -o "$casp" "$1"'
    };;
    svg) {
        if executable_p inkscape && test -z "$dc"; then
            unset filt
            conv='inkscape -z -A "$casp" "$1"'
        else
            missing rsvg-convert "rsvg-convert"
            conv='rsvg-convert -f pdf -o "$casp"'
        fi
    };;
    font) {
        maketext "$1"
        exec llpp "$cachedir/fonts/text.html"
    };;
    image) {
        missing convert "convert(http://www.imagemagick.org/script/convert.php)"
        conv='convert - pdf:"$casp"'
    };;
    dvi) {
        test -n "$dc" && die "cannot convert compressed '$mime'"
        unset filt
        missing dvipdf "dvipdf(http://ghostscript.com/)"
        conv='dvipdf "$1" "$casp"'
    };;
    text) {
        missing pandoc "pandoc(http://pandoc.org/)"
        conv='pandoc -t epub - -o "$casp"'
        caspsuf=.epub
    };;
    *) die "unhandled filter type: '$type'";;
esac

hash=$(md5sum "$md5of") || die "$hash"
casp=$cachedir/${hash%% *}$caspsuf

{ test -n "$force" || test ! -e "$casp"; } && eval "$filt" "$conv"
shift

exec llpp -origin $origin "$@" "$casp"
